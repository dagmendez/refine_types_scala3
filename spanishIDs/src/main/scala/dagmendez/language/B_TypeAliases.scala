package dagmendez.language

/**
 * SCALA TYPE ALIASES
 *
 * Definition: Type aliases in Scala allow you to give alternative names to existing types. They are declared using the 'type' keyword.
 *
 * Syntax: type NewTypeName = ExistingType
 *
 * Example from the code: type NieLetter = String type Number = Int type Letter = String
 *
 * ADVANTAGES OF TYPE ALIASES:
 *
 *   - Improved Readability
 *     - Makes code more domain-specific and self-documenting
 *     - Adds semantic meaning to primitive types
 *     - Easier to understand the purpose of variables
 *   - Reduced Verbosity
 *     - Shortens complex type signatures
 *     - Especially useful for complex generic types
 *   - Maintenance Benefits
 *     - Centralizes type definitions
 *     - Makes refactoring easier
 *   - Documentation Value
 *     - Serves as implicit documentation
 *     - Makes code intentions clearer
 *
 * LIMITATIONS AND CONS:
 *
 *   - No Type Safety
 *     - Type aliases are just synonyms, not new types
 *     - Don't provide additional type checking
 *     - Can't prevent mixing of semantically different values of the same base type
 *   - Potential Confusion
 *     - May mislead developers into thinking they provide type safety
 *     - Can make code more complex if overused
 *   - Compilation Output
 *     - Type aliases are resolved at compile time
 *     - Generated bytecode uses the original types
 *
 * Example of limitation: type Age = Int type Count = Int // Both Age and Count are just Int, so you can mix them without compiler errors
 */

object B_TypeAliases:

  type NieLetter = String
  type Number    = Int
  type Letter    = String

  class DNI(number: Number, letter: Letter):
    override def toString: String = s"$number-$letter"

  class NIE(nieLetter: NieLetter, number: Number, letter: Letter):
    override def toString: String = s"$nieLetter-$number-$letter"

  val validDNI = DNI(1, "R")
  val validNIE = NIE("X", 1, "R")

  // These compile despite being semantically incorrect
  val invalidNIELetter        = NIE("A", 1, "R")     // Invalid NIE letter
  val invalidNegativeNumber   = DNI(-1, "R")         // Negative number
  val invalidTooLongNumber    = DNI(1234567890, "R") // Too long number
  val invalidControlLetterDNI = DNI(1, "Ã‘")          // Invalid control letter

  def main(args: Array[String]): Unit =
    println("== Valid IDs ==")
    println(validDNI)
    println(validNIE)
    println("== Invalid IDs ==")
    println(invalidNIELetter)
    println(invalidNegativeNumber)
    println(invalidTooLongNumber)
    println(invalidControlLetterDNI)

  /**
   * Conclusion: Type Aliases increases code readability but do not give as any additional guaranties
   */
